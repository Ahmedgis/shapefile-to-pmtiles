<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PMTiles Viewer</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.10.0/font/bootstrap-icons.css" rel="stylesheet">
    <link href="https://cdn.jsdelivr.net/npm/maplibre-gl@3.0.0/dist/maplibre-gl.css" rel="stylesheet">
    <link href="{{ url_for('static', filename='css/style.css') }}" rel="stylesheet">
    <link href="{{ url_for('static', filename='favicon.ico') }}" rel="icon" type="image/x-icon">
</head>
<body>
    <div class="container-fluid">
        <div class="row">
            <!-- Sidebar -->
            <div class="col-md-3 sidebar">
                <div class="p-3">
                    <h2>PMTiles Viewer</h2>
                    <p>View your converted PMTiles files</p>
                    
                    <!-- PMTiles File Selector -->
                    <div class="mb-3">
                        <label class="form-label">PMTiles Files</label>
                        <div class="d-flex gap-2 mb-2">
                            <button id="refresh-files" class="btn btn-outline-primary btn-sm">
                                <i class="bi bi-arrow-clockwise"></i> Refresh
                            </button>
                            <span id="file-count" class="badge bg-secondary">0 files</span>
                        </div>
                        <select id="pmtiles-select" class="form-select mb-2">
                            <option value="">Select a PMTiles file...</option>
                        </select>
                        <div class="form-text">
                            <small>Files from: <code id="output-directory">./output</code></small>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Map Style</label>
                        <select id="style-select" class="form-select">
                            <option value="streets">Streets</option>
                            <option value="satellite">Satellite</option>
                            <option value="dark">Dark</option>
                            <option value="light">Light</option>
                        </select>
                    </div>
                    
                    <div class="mb-3">
                        <label class="form-label">Active Layers</label>
                        <div id="layer-list" class="list-group">
                            <!-- Dynamic layer list will be populated here -->
                        </div>
                        <div class="form-text mt-2">
                            <small>Select PMTiles files above to add layers</small>
                        </div>
                    </div>
                    
                    <div class="mb-3">
                        <button id="fit-bounds" class="btn btn-primary w-100">Fit to Data</button>
                        <button id="clear-layers" class="btn btn-outline-danger w-100 mt-2">Clear All Layers</button>
                    </div>
                    
                    <!-- Status Panel -->
                    <div class="mt-4">
                        <h6>Status</h6>
                        <div id="status-panel" class="alert alert-info">
                            <small>Ready to load PMTiles files</small>
                        </div>
                    </div>
                </div>
            </div>
            
            <!-- Map Container -->
            <div class="col-md-9 p-0">
                <div id="map"></div>
            </div>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0-alpha1/dist/js/bootstrap.bundle.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/maplibre-gl@3.0.0/dist/maplibre-gl.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/pmtiles@2.7.0/dist/index.js"></script>
    <script>
        // Initialize map and layers
        document.addEventListener('DOMContentLoaded', function() {
            // PMTiles protocol
            let protocol = new pmtiles.Protocol();
            maplibregl.addProtocol("pmtiles", protocol.tile);
            
            // Map styles
            const styles = {
                streets: 'https://demotiles.maplibre.org/style.json',
                satellite: 'https://api.maptiler.com/maps/hybrid/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
                dark: 'https://api.maptiler.com/maps/darkmatter/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL',
                light: 'https://api.maptiler.com/maps/bright/style.json?key=get_your_own_OpIi9ZULNHzrESv6T2vL'
            };
            
            // Initialize map
            const map = new maplibregl.Map({
                container: 'map',
                style: styles.streets,
                center: [0, 0],
                zoom: 2
            });
            
            // Add navigation controls
            map.addControl(new maplibregl.NavigationControl());
            map.addControl(new maplibregl.ScaleControl());
            
            // Global variables
            let pmtilesFiles = [];
            let activeLayers = new Map();
            let layerBounds = null;
            let layerCounter = 0;
            
            // Status update function
            function updateStatus(message, type = 'info') {
                const statusPanel = document.getElementById('status-panel');
                statusPanel.className = `alert alert-${type}`;
                statusPanel.innerHTML = `<small>${message}</small>`;
            }
            
            // Load PMTiles files from server
            async function loadPMTilesFiles() {
                try {
                    updateStatus('Loading PMTiles files...', 'info');
                    const response = await fetch('/api/pmtiles');
                    const data = await response.json();
                    
                    pmtilesFiles = data.pmtiles_files.filter(file => file.toLowerCase().endsWith('.pmtiles')) || [];
                    
                    // Update file count
                    document.getElementById('file-count').textContent = `${pmtilesFiles.length} files`;
                    
                    // Update output directory display
                    document.getElementById('output-directory').textContent = data.output_directory || './output';
                    
                    // Populate dropdown - only show PMTiles files
                    const select = document.getElementById('pmtiles-select');
                    select.innerHTML = '<option value="">Select a PMTiles file...</option>';
                    
                    // Filter to only show .pmtiles files in the dropdown
                    // const pmtilesOnly = pmtilesFiles.filter(file => file.toLowerCase().endsWith('.pmtiles'));
                    // const pmtilesOnly = pmtilesFiles.filter(file => file.toLowerCase().endsWith('.pmtiles') || file.toLowerCase().endsWith('.geojson'));
                    
                    pmtilesFiles.forEach((file, index) => {
                        const option = document.createElement('option');
                        option.value = file;
                        option.textContent = file.split('/').pop(); // Just filename
                        select.appendChild(option);
                    });
                    
                    if (pmtilesFiles.length === 0) {
                        updateStatus('No data files found in output directory', 'warning');
                    } else if (pmtilesFiles.length === 0) {
                        updateStatus(`Found ${pmtilesFiles.length} data files, but no PMTiles files for dropdown`, 'warning');
                    } else {
                        updateStatus(`Found ${pmtilesFiles.length} PMTiles files available for selection`, 'success');
                    }
                    
                } catch (error) {
                    console.error('Error loading PMTiles files:', error);
                    updateStatus('Error loading PMTiles files', 'danger');
                }
            }
            
            // Add PMTiles or GeoJSON layer function
            function addPMTilesLayer(filePath) {
                if (activeLayers.has(filePath)) {
                    updateStatus('Layer already added', 'warning');
                    return;
                }
                
                const layerId = `layer-${layerCounter}`;
                const sourceId = `source-${layerCounter}`;
                layerCounter++;
                
                try {
                    const fileName = filePath.split('/').pop();
                    const isGeoJSON = fileName.endsWith('.geojson');
                    const isPMTiles = fileName.endsWith('.pmtiles');
                    
                    if (isGeoJSON) {
                        // Handle GeoJSON files
                        fetch(filePath)
                            .then(response => response.json())
                            .then(geojsonData => {
                                // Add GeoJSON source
                                map.addSource(sourceId, {
                                    type: 'geojson',
                                    data: geojsonData
                                });
                                
                                // Determine geometry type and add appropriate layers
                                const firstFeature = geojsonData.features[0];
                                if (firstFeature) {
                                    const geometryType = firstFeature.geometry.type;
                                    
                                    if (geometryType === 'Point' || geometryType === 'MultiPoint') {
                                        // Add circle layer for points
                                        map.addLayer({
                                            id: layerId,
                                            type: 'circle',
                                            source: sourceId,
                                            paint: {
                                                'circle-radius': 8,
                                                'circle-color': getRandomColor(),
                                                'circle-opacity': 0.8,
                                                'circle-stroke-color': '#000000',
                                                'circle-stroke-width': 2
                                            }
                                        });
                                    } else if (geometryType === 'Polygon' || geometryType === 'MultiPolygon') {
                                        // Add fill layer for polygons
                                        map.addLayer({
                                            id: layerId,
                                            type: 'fill',
                                            source: sourceId,
                                            paint: {
                                                'fill-color': getRandomColor(),
                                                'fill-opacity': 0.7
                                            }
                                        });
                                        
                                        // Add outline layer
                                        const outlineLayerId = `${layerId}-outline`;
                                        map.addLayer({
                                            id: outlineLayerId,
                                            type: 'line',
                                            source: sourceId,
                                            paint: {
                                                'line-color': '#000000',
                                                'line-width': 2
                                            }
                                        });
                                    } else {
                                        // Add line layer for other geometries
                                        map.addLayer({
                                            id: layerId,
                                            type: 'line',
                                            source: sourceId,
                                            paint: {
                                                'line-color': getRandomColor(),
                                                'line-width': 3
                                            }
                                        });
                                    }
                                }
                                
                                // Store layer info
                                activeLayers.set(filePath, {
                                    layerId: layerId,
                                    outlineLayerId: geometryType === 'Polygon' || geometryType === 'MultiPolygon' ? `${layerId}-outline` : null,
                                    sourceId: sourceId,
                                    visible: true,
                                    bounds: calculateBounds(geojsonData)
                                });
                                
                                // Add to layer list UI
                                addLayerToUI(filePath, layerId);
                                
                                updateStatus(`Added GeoJSON layer: ${fileName}`, 'success');
                            })
                            .catch(error => {
                                console.error('Error loading GeoJSON:', error);
                                updateStatus(`Error loading GeoJSON: ${error.message}`, 'danger');
                            });
                            
                    } else if (isPMTiles) {
                        // Handle PMTiles files (metadata-first flow)
                        (async () => {
                            try {
                                const pmtilesUrl = new URL(filePath, window.location.origin).href;
                                const p = new pmtiles.PMTiles(pmtilesUrl);
                                const metadata = await p.getMetadata();
                                const bounds = (metadata && Array.isArray(metadata.bounds) && metadata.bounds.length === 4)
                                    ? [[metadata.bounds[0], metadata.bounds[1]], [metadata.bounds[2], metadata.bounds[3]]] : null;
                                const layerIdFromTj = (metadata && Array.isArray(metadata.vector_layers) && metadata.vector_layers.length > 0)
                                    ? metadata.vector_layers[0].id : 'default';
                                
                                map.addSource(sourceId, {
                                    type: 'vector',
                                    url: `pmtiles://${pmtilesUrl}`,
                                    attribution: 'PMTiles'
                                });
                                
                                map.addLayer({
                                    id: layerId,
                                    type: 'fill',
                                    source: sourceId,
                                    'source-layer': layerIdFromTj,
                                    paint: {
                                        'fill-color': getRandomColor(),
                                        'fill-opacity': 0.7,
                                        'fill-outline-color': '#000000'
                                    }
                                });
                                
                                const outlineLayerId = `${layerId}-outline`;
                                map.addLayer({
                                    id: outlineLayerId,
                                    type: 'line',
                                    source: sourceId,
                                    'source-layer': layerIdFromTj,
                                    paint: {
                                        'line-color': '#000000',
                                        'line-width': 1
                                    }
                                });
                                
                                activeLayers.set(filePath, {
                                    layerId: layerId,
                                    outlineLayerId: outlineLayerId,
                                    sourceId: sourceId,
                                    visible: true,
                                    bounds: bounds
                                });
                                
                                addLayerToUI(filePath, layerId);
                                updateStatus(`Added PMTiles layer: ${fileName}`, 'success');
                            } catch (e) {
                                console.error('Error loading PMTiles metadata:', e);
                                updateStatus(`Error loading PMTiles: ${e.message}`, 'danger');
                            }
                        })();
                    }
                    
                } catch (error) {
                    console.error('Error adding layer:', error);
                    updateStatus(`Error adding layer: ${error.message}`, 'danger');
                }
            }
            
            // Calculate bounds from GeoJSON data
            function calculateBounds(geojsonData) {
                let minLng = Infinity, minLat = Infinity;
                let maxLng = -Infinity, maxLat = -Infinity;
                
                geojsonData.features.forEach(feature => {
                    const coords = feature.geometry.coordinates;
                    
                    function processCoordsArray(coordsArray) {
                        if (typeof coordsArray[0] === 'number') {
                            // Single coordinate pair
                            const [lng, lat] = coordsArray;
                            minLng = Math.min(minLng, lng);
                            maxLng = Math.max(maxLng, lng);
                            minLat = Math.min(minLat, lat);
                            maxLat = Math.max(maxLat, lat);
                        } else {
                            // Array of coordinates
                            coordsArray.forEach(processCoordsArray);
                        }
                    }
                    
                    processCoordsArray(coords);
                });
                
                return [[minLng, minLat], [maxLng, maxLat]];
            }
            
            // Add layer to UI list
            function addLayerToUI(pmtilesFile, layerId) {
                const layerList = document.getElementById('layer-list');
                const fileName = pmtilesFile.split('/').pop();
                
                const layerItem = document.createElement('div');
                layerItem.className = 'list-group-item';
                layerItem.id = `layer-ui-${layerId}`;
                
                layerItem.innerHTML = `
                    <div class="d-flex justify-content-between align-items-center">
                        <div class="form-check">
                            <input class="form-check-input layer-toggle" type="checkbox" 
                                   value="${pmtilesFile}" id="toggle-${layerId}" checked>
                            <label class="form-check-label" for="toggle-${layerId}">
                                ${fileName}
                            </label>
                        </div>
                        <button class="btn btn-outline-danger btn-sm remove-layer" 
                                data-file="${pmtilesFile}" data-layer="${layerId}">
                            Remove
                        </button>
                    </div>
                `;
                
                layerList.appendChild(layerItem);
                
                // Add event listeners
                const checkbox = layerItem.querySelector('.layer-toggle');
                checkbox.addEventListener('change', function() {
                    toggleLayerVisibility(pmtilesFile, this.checked);
                });
                
                const removeBtn = layerItem.querySelector('.remove-layer');
                removeBtn.addEventListener('click', function() {
                    removeLayer(pmtilesFile);
                });
            }
            
            // Toggle layer visibility
            function toggleLayerVisibility(pmtilesFile, visible) {
                const layerInfo = activeLayers.get(pmtilesFile);
                if (layerInfo) {
                    const visibility = visible ? 'visible' : 'none';
                    map.setLayoutProperty(layerInfo.layerId, 'visibility', visibility);
                    map.setLayoutProperty(layerInfo.outlineLayerId, 'visibility', visibility);
                    layerInfo.visible = visible;
                }
            }
            
            // Remove layer
            function removeLayer(pmtilesFile) {
                const layerInfo = activeLayers.get(pmtilesFile);
                if (layerInfo) {
                    // Remove from map
                    map.removeLayer(layerInfo.layerId);
                    map.removeLayer(layerInfo.outlineLayerId);
                    map.removeSource(layerInfo.sourceId);
                    
                    // Remove from UI
                    const layerUI = document.getElementById(`layer-ui-${layerInfo.layerId}`);
                    if (layerUI) {
                        layerUI.remove();
                    }
                    
                    // Remove from active layers
                    activeLayers.delete(pmtilesFile);
                    
                    updateStatus(`Removed layer: ${pmtilesFile.split('/').pop()}`, 'info');
                }
            }
            
            // Clear all layers
            function clearAllLayers() {
                const filesToRemove = Array.from(activeLayers.keys());
                filesToRemove.forEach(file => removeLayer(file));
                updateStatus('All layers cleared', 'info');
            }
            
            // Fit map to bounds of all visible layers
            async function fitToBounds() {
                if (activeLayers.size === 0) {
                    updateStatus('No active layers to fit bounds', 'warning');
                    return;
                }
                
                // Ensure bounds are available for visible layers; fetch if missing for PMTiles
                const fetchPromises = [];
                activeLayers.forEach((layerInfo, filePath) => {
                    if (layerInfo.visible && !layerInfo.bounds && filePath.toLowerCase().endsWith('.pmtiles')) {
                        const pmtilesUrl = new URL(filePath, window.location.origin).href;
                        const p = new pmtiles.PMTiles(pmtilesUrl);
                        fetchPromises.push(p.getMetadata().then(metadata => {
                            // if (metadata && Array.isArray(metadata.bounds) && metadata.bounds.length === 4) {
                            const bounds = metadata.bounds || (
                                metadata.antimeridian_adjusted_bounds &&
                                metadata.antimeridian_adjusted_bounds.split(',').map(Number)
                            );
                            if (bounds && Array.isArray(bounds) && bounds.length === 4) {
                                const [minLng, minLat, maxLng, maxLat] = bounds;
                                const info = activeLayers.get(filePath);
                                if (info) info.bounds = [[minLng, minLat], [maxLng, maxLat]];
                            }
                        }).catch(() => {}));
                    }
                });
                
                if (fetchPromises.length > 0) {
                    await Promise.all(fetchPromises);
                }
                
                let combinedBounds = null;
                let visibleWithBounds = 0;
                
                activeLayers.forEach((layerInfo, filePath) => {
                    if (layerInfo.visible && layerInfo.bounds) {
                        const [[minLng, minLat], [maxLng, maxLat]] = layerInfo.bounds;
                        visibleWithBounds += 1;
                        
                        if (!combinedBounds) {
                            combinedBounds = [[minLng, minLat], [maxLng, maxLat]];
                        } else {
                            combinedBounds[0][0] = Math.min(combinedBounds[0][0], minLng);
                            combinedBounds[0][1] = Math.min(combinedBounds[0][1], minLat);
                            combinedBounds[1][0] = Math.max(combinedBounds[1][0], maxLng);
                            combinedBounds[1][1] = Math.max(combinedBounds[1][1], maxLat);
                        }
                    }
                });
                
                if (combinedBounds) {
                    map.fitBounds(combinedBounds, {
                        padding: 50,
                        maxZoom: 15
                    });
                    updateStatus('Fitted map to data bounds', 'success');
                } else {
                    map.flyTo({
                        center: [0, 0],
                        zoom: 2
                    });
                    updateStatus('No layer bounds found; flew to world view', 'info');
                }
            }
            
            // Fetch PMTiles bounds using metadata
            async function loadPMTilesBounds(filePath) {
                try {
                    const pmtilesUrl = new URL(filePath, window.location.origin).href;
                    const p = new pmtiles.PMTiles(pmtilesUrl);
                    const metadata = await p.getMetadata();
                    if (metadata && Array.isArray(metadata.bounds) && metadata.bounds.length === 4) {
                        const [minLng, minLat, maxLng, maxLat] = metadata.bounds;
                        return [[minLng, minLat], [maxLng, maxLat]];
                    }
                    return null;
                } catch (e) {
                    console.warn('PMTiles metadata fetch failed:', e);
                    return null;
                }
            }
            
            // Generate random color for layers
            function getRandomColor() {
                const letters = '0123456789ABCDEF';
                let color = '#';
                for (let i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }
            
            // Event listeners
            document.getElementById('pmtiles-select').addEventListener('change', function() {
                if (this.value) {
                    addPMTilesLayer(this.value);
                    this.value = ''; // Reset selection
                }
            });
            
            document.getElementById('refresh-files').addEventListener('click', loadPMTilesFiles);
            document.getElementById('fit-bounds').addEventListener('click', fitToBounds);
            document.getElementById('clear-layers').addEventListener('click', clearAllLayers);
            
            // Style selector
            document.getElementById('style-select').addEventListener('change', function() {
                map.setStyle(styles[this.value]);
                
                // Re-add layers after style change
                map.once('styledata', function() {
                    const layersToReAdd = Array.from(activeLayers.keys());
                    activeLayers.clear();
                    layerCounter = 0;
                    
                    // Clear UI
                    document.getElementById('layer-list').innerHTML = '';
                    
                    // Re-add layers
                    layersToReAdd.forEach(file => {
                        addPMTilesLayer(file);
                    });
                });
            });
            
            // Initialize
            map.on('load', function() {
                loadPMTilesFiles();
            });
        });
    </script>
</body>
</html>